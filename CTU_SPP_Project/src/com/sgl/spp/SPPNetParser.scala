package com.sgl.spp

import scala.collection.mutable.ArrayBuffer

object SPPNetParser {

  /**
    * 将某个特征的特征值形成序列，分别生成其mean、stochastic、sum的SPP结果序列。返回结果为64*3
    * @param src
    * @return
    */
  def oneDimSPPNet(src:Array[Double]):ArrayBuffer[Double] = {

    var rstBuff = new ArrayBuffer[Double]()
    var srcBuff = new ArrayBuffer[Double]()
    srcBuff.insertAll(0, src)

    val layerSizes:Array[Int]=Array(32, 16, 8, 4, 2, 1)
    for(i <- 0 to layerSizes.length-1) {
      rstBuff ++= oneDimByLayer(src, layerSizes(i), "mean")
    }
    for(i <- 0 to layerSizes.length-1) {
      rstBuff ++= oneDimByLayer(src, layerSizes(i), "stochastic")
    }
    for(i <- 0 to layerSizes.length-1) {
      rstBuff ++= oneDimByLayer(src, layerSizes(i), "sum")
    }

    //println(rstBuff.size)
    rstBuff
  }


  /**
    * 将一维数据划分成layerSize段小数据，每段数据pooling，最后返回layerSize个结果
    * @param src
    * @param layerSize
    * @param poolingType
    * @return
    */
  def oneDimByLayer(src:Array[Double], layerSize:Int, poolingType:String):ArrayBuffer[Double] = {

    var rstBuff = new ArrayBuffer[Double]()

    var srcBuff = new ArrayBuffer[Double]()
    srcBuff.insertAll(0, src)
    val gridLen = Math.round(src.length*1.0/layerSize).toInt

    //padding
    if(gridLen > src.length/layerSize) {
      val len = gridLen*layerSize - src.length
      for(i <- 0 to len-1) {
        srcBuff += srcBuff(i.toInt)
      }
    }

    val lastIndex = gridLen.toInt*layerSize-1
    val step = gridLen.toInt

    var i = 0
    while(i<=lastIndex) {
      var tmpArr = new Array[Double](step)
      for(j <- 0 to step-1) {
        tmpArr(j) = srcBuff.apply(j + i)
      }

      rstBuff += pooling(tmpArr, poolingType)
      i = i+step
    }

    rstBuff
  }




  /**
    * 连续型数据的pooling实现
    * @param src
    * @param poolingType
    * @return
    */
  def pooling(src:Array[Double], poolingType:String):Double = {
    var poolingRst = 0.0
    if(poolingType.equals("mean")) {
      src.foreach(item => poolingRst += item)
      poolingRst = poolingRst/src.length
    }
    else if(poolingType.equals("stochastic")) {
      val max = src.map(item => (item, 1)).groupBy(_._1).map(item => (item._2.size, item._1)).max
      poolingRst = max._2
    }
    else if(poolingType.equals("sum")) {
      src.foreach(item => poolingRst += item)
    }
    poolingRst
  }




}