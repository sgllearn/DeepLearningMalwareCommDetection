package com.sgl.preprocessing

import java.io.File

import com.sgl.util.FileUtil

import scala.collection.mutable.ArrayBuffer
import scala.io.Source

//2270 ~ 1890
//1136 ~ 756
object Preprocess_Normalization_ZScore {


  var meanPara:Array[Double] = Array()
  var sdPara:Array[Double] = Array()


  def main(args: Array[String]): Unit = {

    println("java -cp  ctu_db_fetch.jar com.sgl.ctu_db_fetch.Preprocess_Normalization_ZScore2 /xx/ 1134 calParam|doNormalization")


    var dir = args(0)//"
    if(!dir.endsWith("/"))
      dir = dir + "/"
    println(args(0))
    val dim = Integer.parseInt(args(1))
    val op = args(2)



    if(op.equals("calParam")) {
      calMeanFai(dir, dim);
    }
    else if(op.equals("doNormalization")) {
      doNormalization(dir, dim);
    }
    else {
      println("OP wrong")
    }


//    doNormalization(dir, "background.txt");
//    doNormalization(dir, "botnet.txt");
//    for(i <- 1 to 7) {
//      doNormalization_NoSampleName(dir, "dl_input_sampleValue_2018-01-0"+i+".txt");
//    }
    //doNormalization_NoSampleName(dir, "dl_input_sampleValue_2017-06-02.txt");
//    doNormalization_NoSampleName(args(0), args(1))

  }

  def doNormalization(dir:String, dim:Int)= {

    for (line <- Source.fromFile(dir+"param_mean.txt").getLines) {
      val items = line.trim().split(", ")
      if(items.length==dim) {
        var arr:Array[Double] = new Array[Double](dim)
        for(i <- 0 to arr.length-1) {
          arr(i) = items(i).toDouble
        }
        meanPara = arr
      }
    }
    for (line <- Source.fromFile(dir+"param_sd.txt").getLines) {
      val items = line.trim().split(", ")
      if(items.length==dim) {
        var arr:Array[Double] = new Array[Double](dim)
        for(i <- 0 to arr.length-1) {
          arr(i) = items(i).toDouble
        }
        sdPara = arr
      }
    }


    val dirFile = new File(dir)
    val files = dirFile.listFiles
    for (file <- files) {

      val filename = file.getName
      if(filename.contains("withlabel")) {
        doNormalization_withlabel(dir, filename, dim)
      }
      else if(filename.contains("withoutlabel")) {
        doNormalization_withoutlabel(dir, filename, dim)
      }
    }
  }

  def doNormalization_withlabel(dir:String, filename:String, dim:Int) = {

    var srcBuff = new ArrayBuffer[Array[Double]]()
    var labelBuff = new ArrayBuffer[String]()

    for (line <- Source.fromFile(dir+filename).getLines) {
      val items = line.trim().split("\t")
      if(items.length==dim+2) {
        var arr:Array[Double] = new Array[Double](dim)
        for(i <- 0 to arr.length-1) {
          arr(i) = items(2+i).toDouble
        }
        srcBuff.append(arr)
        labelBuff.append(items(0)+"\t"+items(1))
      }
    }

    val normBuff = srcBuff.map(item => {
      var newArr:Array[Double] = new Array[Double](item.length)
      for(i <- 0 to item.length-1) {
           newArr(i) = (item(i)-meanPara(i))/sdPara(i)
        }
      newArr
    })

    //val normStrBuff = normBuff.map(item => item.toBuffer.mkString("\t").trim)

    for(i <- 0 to normBuff.length-1) {
      FileUtil.saveString(dir+filename.replace(".txt", "")+"_norm.txt", labelBuff(i)+"\t"+normBuff(i).mkString("\t").trim+"\r\n", true)
    }
  }
  def doNormalization_withoutlabel(dir:String, filename:String, dim:Int) = {

    var srcBuff = new ArrayBuffer[Array[Double]]()
    //var labelBuff = new ArrayBuffer[String]()

    for (line <- Source.fromFile(dir+filename).getLines) {
      val items = line.trim().split("\t")
      if(items.length==dim) {
        var arr:Array[Double] = new Array[Double](dim)
        for(i <- 0 to arr.length-1) {
          arr(i) = items(i).toDouble
        }
        srcBuff.append(arr)
        //labelBuff.append(items(0)+"\t"+items(1))
      }
    }

    val normBuff = srcBuff.map(item => {
      var newArr:Array[Double] = new Array[Double](item.length)
      for(i <- 0 to item.length-1) {
        newArr(i) = (item(i)-meanPara(i))/sdPara(i)
      }
      newArr
    })

    //val normStrBuff = normBuff.map(item => item.toBuffer.mkString("\t").trim)

    for(i <- 0 to normBuff.length-1) {
      FileUtil.saveString(dir+filename.replace(".txt", "")+"_norm.txt", normBuff(i).mkString("\t").trim+"\r\n", true)
    }
  }



  def calMeanFai(dir:String, dim:Int)= {

    var srcBuff = new ArrayBuffer[Array[Double]]()

    val dirFile = new File(dir)
    val files = dirFile.listFiles
    for (file <- files) {

      val filename = file.getName
      if(filename.contains("withlabel")) {
        for (line <- Source.fromFile(file.getAbsoluteFile).getLines) {
          val items = line.trim().split("\t")
          if(items.length==dim+2) {
            var arr:Array[Double] = new Array[Double](dim)
            for(i <- 0 to arr.length-1) {
              arr(i) = items(i+2).toDouble
            }
            srcBuff.append(arr)
          }
        }

      }
      else if(filename.contains("withoutlabel")) {
        for (line <- Source.fromFile(file.getAbsoluteFile).getLines) {
          val items = line.trim().split("\t")
          if(items.length==dim) {
            var arr:Array[Double] = new Array[Double](dim)
            for(i <- 0 to arr.length-1) {
              arr(i) = items(i).toDouble
            }
            srcBuff.append(arr)
          }
        }
      }
    }

    val mean = srcBuff.reduce((x,y) => {
      var newArr:Array[Double] = new Array[Double](dim)
      for(i <- 0 to x.length-1) {
        newArr(i) = x(i)+y(i)
      }
      newArr
    }).map(item => item/srcBuff.size)
    //println(mean.toBuffer.mkString(", "))
    FileUtil.saveString("param_mean.txt", mean.toBuffer.mkString(", "), false)


    val sd = srcBuff.map(x => {
      var newArr:Array[Double] = new Array[Double](dim)
      for(i <- 0 to x.length-1) {
        newArr(i) = x(i)-mean(i)
        newArr(i) = newArr(i)*newArr(i)
      }
      newArr
    })
      .reduce((x,y) => {
        var newArr:Array[Double] = new Array[Double](dim)
        for(i <- 0 to x.length-1) {
          newArr(i) = x(i)+y(i)
        }
        newArr
      }).map(item => Math.sqrt(item/srcBuff.size))

    //println(sd.toBuffer.mkString(", "))
    FileUtil.saveString("param_sd.txt", sd.toBuffer.mkString(", "), false)

  }

}
